<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ctrl</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ctrl</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/postmannen/ctrl" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>ctrl is a Command &amp; Control (C2) backend system for Servers, IOT and Edge platforms. Simply put, control anything like a Fleet Manager.</p>
<p>In operations ctrl can be used to send a set of commands to execute to a node, a group of nodes, or all nodes. It can also be used to gather operational data like logs and metrics from all the ctrl nodes.</p>
<p>In forensics ctrl can be used to execute commands with tools to gather information needed. If the tools are not already present on an end ctrl node, ctrl can be used to copy the tools to that node, and then ctrl can run them to gather information.</p>
</style>
</head>
<body>
<p align="center"><img src="https://github.com/postmannen/ctrl/blob/main/doc/core-messaging.svg?raw=true" /></p>
</body>
<h2 id="usecases"><a class="header" href="#usecases">Usecases</a></h2>
<p>Some example usecases are:</p>
<ul>
<li>Send shell commands or scripts to control one or many end nodes that will instruct to change config, restart services and control those systems.</li>
<li>Gather data from both secure and not secure devices and systems, and transfer them encrypted in a secure way over the internet to your central system for handling those data.</li>
<li>Collect metrics or monitor end nodes, then send and store the result to some ctrl instance, or pass those data's on to another ctrl instance for further handling of metrics or monitoring data.</li>
<li>Distribute certificates.</li>
<li>Run as a sidecar in Kubernetes for direct access to the pod.</li>
</ul>
<p>Ctrl is a versatile tool that enables users to control their systems with precision and efficiency. It's designed as a fleet manager, leveraging NATS as its messaging architecture, allowing for secure and encrypted communication between an operator and one or more servers.</p>
<p>With Ctrl, you can accomplish tasks that you typically perform on a shell in a system - all with simple messages, using Ctrl's request methods. This feature allows for the execution of commands on remote servers, even if they are down at the time of sending. Messages will be retried based on the specified criteria in their body.</p>
<p>Ctrl is built to handle multiple messages independently, by utilizing Go, the programming languages builtin concurrency. It can handle tasks such as executing a slow process without affecting other processes or systems. If a process fails, Ctrl ensures that it doesn't affect other operations, providing a reliable and robust system control solution.</p>
<p>Furthermore, Ctrl is highly compatible with various host operating systems. It supports cloud containers, Raspberry Pi, and any other device with an installed operating system. It can run on a variety of architectures such as x86, amd64, arm64, ppc64, making it a versatile tool for system
administration.</p>
<p>Ctrl is compatible with most major operating systems including Linux, OSX, and Windows, giving users the flexibility to use Ctrl across different platforms.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="install-with-docker"><a class="header" href="#install-with-docker">Install with docker</a></h1>
<p>Start up a local nats message broker</p>
<pre><code class="language-bash">docker run -p 4444:4444 nats -p 4444
</code></pre>
<p>Create a ctrl docker image.</p>
<pre><code class="language-bash">git clone git@github.com:postmannen/ctrl.git
cd ctrl
docker build -t ctrl:test1 .
</code></pre>
<p>Create a folder which will be the working directory for the node. This is where we keep the .env file, and can mount local host folders to folders within the container.</p>
<pre><code class="language-bash">mkdir -p testrun/readfolder
cd testrun
</code></pre>
<p>create a .env file</p>
<pre><code class="language-bash">cat &lt;&lt; EOF &gt; .env
NODE_NAME="node1"
BROKER_ADDRESS="127.0.0,1:4444"
NKEY_SEED=&lt;REPLACE WITH seed created for the node&gt;
ENABLE_DEBUG=1
START_PUB_HELLO=60
IS_CENTRAL_ERROR_LOGGER=0
EOF
</code></pre>
<p>Start the ctrl container. To be able to send messages into ctrl we mount the readfolder to a local directory. When we later got a messages to send we just copy it into the read folder and ctrl will pick it up and handle it. Messages can be in either YAML or JSON format.</p>
<pre><code class="language-bash">docker run --env-file=".env" --rm -ti -v $(PWD)/readfolder:/app/readfolder ctrl:test1
</code></pre>
<p>Prepare and send a message.</p>
<pre><code class="language-yaml">cat &lt;&lt; EOF &gt; msg.yaml
---
- toNodes:
    - node1
  method: cliCommand
  methodArgs:
    - "bash"
    - "-c"
    - |
      echo "some config line" &gt; /etc/my-service-config.1
      echo "some config line" &gt; /etc/my-service-config.2
      echo "some config line" &gt; /etc/my-service-config.3
      systemctl restart my-service

  replyMethod: none
  ACKTimeout: 0
EOF

cp msg.yaml readfolder
</code></pre>
<p>With the above message we send to ourselves since we only got 1 node running. To start up more nodes repeat the above steps, replace the node name under <code>toNodes</code> with new names for new nodes.
NB: If more nodes share the same name the requests will be loadbalanced between them round robin.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="install-on-a-host"><a class="header" href="#install-on-a-host">Install on a host</a></h1>
<p>Start up a local nats message broker if you don't already have one.</p>
<pre><code class="language-bash">docker run -p 4444:4444 nats -p 4444
</code></pre>
<p>Build the ctrl binary from the source code.</p>
<pre><code class="language-bash">git clone git@github.com:postmannen/ctrl.git
cd cmd/ctrl
go run build
</code></pre>
<p>Copy the binary to <code>/usr/local</code>.</p>
<pre><code class="language-bash">mkdir -p /usr/local/ctrl
cp ./ctrl /usr/local/ctrl
</code></pre>
<pre><code class="language-bash">
For testing we create a folder for the node to store it's data.

```bash
cd /usr/local/ctrl
mkdir node1
cd node1
</code></pre>
<p>ctrl will create all the folders needed like etc, var and more in the current directory where it was started if they don't already exist. This behaviour can be changed with flags or env variables.</p>
<p>Create a .env file for the startup options. Flags can also be used.</p>
<pre><code class="language-bash">cat &lt;&lt; EOF &gt; .env
NODE_NAME="node1"
BROKER_ADDRESS="127.0.0,1:4444"
ENABLE_DEBUG=1
START_PUB_HELLO=60
IS_CENTRAL_ERROR_LOGGER=0
EOF
</code></pre>
<p>Start up ctrl. ctrl will automatically used the local .env file we created.</p>
<pre><code class="language-bash">../usr/local/ctrl/ctrl
</code></pre>
<p>If you open another window, and go to the <code>/usr/local/ctrl/node1</code> you should see that ctrl have created the directory structure for you with ./etc, ./var, ./directoryfolder and so on.</p>
<p>Prepare and send a message. We send messages by copying them into the ./readfolder where ctrl automatically will pick it up, and process it.</p>
<pre><code class="language-yaml">cat &lt;&lt; EOF &gt; msg.yaml
---
- toNodes:
    - node1
  method: cliCommand
  methodArgs:
    - "bash"
    - "-c"
    - |
      echo "some config line" &gt; /etc/my-service-config.1
      echo "some config line" &gt; /etc/my-service-config.2
      echo "some config line" &gt; /etc/my-service-config.3
      systemctl restart my-service

  replyMethod: none
  ACKTimeout: 0
EOF

cp msg.yaml readfolder
</code></pre>
<p>With the above message we send to ourselves since we only got 1 node running. To start up more nodes repeat the above steps, replace.</p>
<h2 id="run-as-service"><a class="header" href="#run-as-service">Run as service</a></h2>
<p>Create a systemctl unit file to run ctrl as a service on the host</p>
<pre><code class="language-bash">progName="ctrl"
systemctlFile=/etc/systemd/system/$progName.service

cat &gt;$systemctlFile &lt;&lt;EOF
[Unit]
Description=http-&gt;${progName} service
Documentation=https://github.com/postmannen/ctrl
After=network-online.target nss-lookup.target
Requires=network-online.target nss-lookup.target

[Service]
ExecStart=env CONFIG_FOLDER=/usr/local/${progName}/etc /usr/local/${progName}/${progName}

[Install]
WantedBy=multi-user.target
EOF

systemctl enable $progName.service &amp;&amp;
systemctl start $progName.service
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nats-server-install"><a class="header" href="#nats-server-install">NATS Server install</a></h1>
<p>ctrl uses NATS as the messagaging backbone. The following text will describe how to quickly get up and running with a minimal NATS setup. For full details of what you can do with nats-server, check out the official docs at <a href="https://docs.nats.io/running-a-nats-service/introduction/installation">https://docs.nats.io/running-a-nats-service/introduction/installation</a></p>
<h2 id="nkey"><a class="header" href="#nkey">NKEY</a></h2>
<p>NATS uses ED25519 based keys called NKEY's for Authentication and Authorization. The keys are created by a tool called <strong>nk</strong>. The instructions for how to install it are found here <a href="https://docs.nats.io/using-nats/nats-tools/nk">https://docs.nats.io/using-nats/nats-tools/nk</a>.</p>
<p>The private key are called <strong>seed</strong>, and the public key are called <strong>user</strong>.</p>
<p>To create the keys run the following command after the nk tool is installed.</p>
<pre><code class="language-bash">nk -gen user -pubout
</code></pre>
<p>The tool will print out two new keys. Where the private Seed starts with the letter <code>S</code>, and the public User key starts with the letter <code>U</code>.</p>
<p>The private Seed key are used with each ctrl instance, and are referenced as an ENV, flag, or via file.</p>
<p>The public User key are used in the nats-server config file for Authentication, to define access lists for what Nats Subjects the ctrl instances should be allowed to send to, or receive from.</p>
<h2 id="install-the-nats-server"><a class="header" href="#install-the-nats-server">Install the NATS Server</a></h2>
<p>For this example we use docker compose to start the NATS server.</p>
<p>On your local computer create a folder to hold the NATS docker compose, and configuration files.</p>
<pre><code class="language-bash">mkdir nats &amp;&amp; cd nats
</code></pre>
<p>create the docker compose file called <code>nats.yaml</code>, with the following content.</p>
<pre><code class="language-yaml">version: "3"

services:
  nats:
    build: .
    image: nats:latest
    # -js enables jetstram on the nats server.
    command: "-c /app/nats-server.conf -D -js"
    restart: always
    ports:
      - "4222:4222"
    volumes:
      - ./nats.conf:/app/nats-server.conf
    logging:
        driver: "json-file"
        options:
            max-size: "10m"
            max-file: "10"
</code></pre>
<p>In the same directory create the nats-server.conf file, with the following content. Replace the placeholders for the user keys in the acl with the user keys you created earlier.</p>
<pre><code class="language-json">port: 4222

ACL = {
    publish: {
            allow: ["&gt;"]
    }
    subscribe: {
            allow: ["&gt;"]
    }
}

authorization: {
    timeout: "30s"
    users = [
        {
            # github
            nkey: &lt;REPLACE WITH github user key here&gt;
            permissions: $ACL
        },
        {
            # node1
            nkey: &lt;REPLACE WITH seed user key here&gt;
            permissions: $ACL
        },
    ]
}
</code></pre>
<h2 id="firewall-openings-for-nats-server"><a class="header" href="#firewall-openings-for-nats-server">Firewall openings for NATS Server</a></h2>
<p>You will need to open your firewall for inbound <code>tcp/4222</code> from the internet.</p>
<p>You can find your public ip address here <a href="https://ipv4.jsonip.com/">https://ipv4.jsonip.com/</a>.</p>
<h2 id="other"><a class="header" href="#other">Other</a></h2>
<p>More details like how to use certificates to encrypt the communication can be found in the official nats docs, <a href="https://docs.nats.io/">https://docs.nats.io/</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-overview"><a class="header" href="#core-overview">Core overview</a></h1>
<p>This is just a quick introduction to the core concepts of ctrl. Details can be found by reading further in the <strong>Core ctrl</strong> section.</p>
<h2 id="concept"><a class="header" href="#concept">Concept</a></h2>
<p>In ctrl all nodes are treated equally, and there is no concept of client/server. There are just nodes that can send messages to other nodes, and the messages contains commands of what to do on the node that receives the message.</p>
<style>
img {
  background-color: #FFFFFF;
}
</style>
</head>
<body>
<p align="center"><img src="https://github.com/postmannen/ctrl/blob/main/doc/core-messaging.svg?raw=true" /></p>
</body>
<p>A message can be sent from a node to one, many, groups or all nodes with a command to execute, and the result of when the command is done will be sent back to where the message originated.</p>
<h2 id="central"><a class="header" href="#central">Central</a></h2>
<p>There should be at least one node acting as the <strong>central</strong> in each environment. The central node will have functionality like:</p>
<ul>
<li>Audit logging of all commands sent and executed on nodes.</li>
<li>Handling and distributing keys for signing messages.</li>
<li>Handling and distributing Access Lists (ACL) for authorizing messages.</li>
<li>General error logging.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="messaging"><a class="header" href="#messaging">Messaging</a></h1>
<p>The handling of all messages is done by spawning up a process for handling the message in it's own thread. This allows us for indivudual control of each message both in regards to ACK's, error handling, send retries, and reruns of methods for a message if the first run was not successful.</p>
<p>All messages processed by a publisher will be written to a log file after they are processed, with all the information needed to recreate the same message if needed, or it can be used for auditing.</p>
<h2 id="message-types-of-both-acknowledge-and-no-acknoweldge"><a class="header" href="#message-types-of-both-acknowledge-and-no-acknoweldge">Message types of both <strong>Acknowledge</strong> and <strong>No-Acknoweldge</strong>:</a></h2>
<ul>
<li><strong>ACKTimeout</strong> set to 0 will make the message become a <strong>No ACK</strong> message.</li>
<li><strong>ACKTimeout</strong> set to &gt;=1 will make the message become an <strong>ACK</strong> message.</li>
</ul>
<p>If ACK is expected, and not received, then the message will be retried the amount of time defined in the <strong>retries</strong> field of a message. If numer of retries are reached, and still no ACK received, the message will be discared, and a log message will be sent to the log server.</p>
<p>To make things easier, all timeouts used for messages can be set with env variables or flags at startup of ctrl. Locally specified timeouts directly in a message will override the startup values, and can be used for more granular control when needed.</p>
<h2 id="example-of-message-flow"><a class="header" href="#example-of-message-flow">Example of message flow:</a></h2>
<style>
img {
  background-color: #FFFFFF;
}
</style>
</head>
<body>
<p align="center"><img src="https://github.com/postmannen/ctrl/blob/main/doc/message-flow.svg?raw=true" /></p>
</body>
<h2 id="handling-the-result-of-a-successful-message-delivery"><a class="header" href="#handling-the-result-of-a-successful-message-delivery">Handling the result of a successful message delivery</a></h2>
<h3 id="default-reply"><a class="header" href="#default-reply">Default reply</a></h3>
<p>We can decide what to do with the result of a message, and it's method have run successfully. By default if nothing is specified ctrls <strong>file</strong> method will be used. The result will be written to ctrl's <strong>data folder</strong>, and structured with the name of the node the result came from. This behavior can be overridden by defining the <strong>directory</strong> and <strong>fileName</strong> fields in the message body.</p>
<p>If no reply is wanted, set the <strong>replyMethod</strong> to <strong>none</strong></p>
<h3 id="setting-your-own-replymethod"><a class="header" href="#setting-your-own-replymethod">Setting your own replyMethod</a></h3>
<p>All methods that can be used as a method in message, can also be used as a <strong>replyMethod</strong>.</p>
<p>As an example we can use the <strong>cliCommand</strong> also as <strong>replyMethod</strong>.</p>
<pre><code class="language-json">[
    {
        "toNode": "node2",
        "method": "cliCommand",
        "methodArgs": [
            "bash",
            "-c",
            "curl localhost:2111/metrics"
        ],
        "replyMethod": "cliCommand",
        "replyMethodArgs": [
            "bash",
            "-c",
            "echo \"{{CTRL_DATA}}\"&gt; /somedirectory/somefile.html"
        ],
        "methodTimeout": 10
    }
]
</code></pre>
<p>The use of {{CTRL_DATA}} allows us to take the result of the initial method, and embed that in the reply message. The use are further explained in <a href="core_messaging_CTRL_DATA.html">{{CTRL_DATA}} variable</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="message-fields"><a class="header" href="#message-fields">Message fields</a></h1>
<h2 id="schema-for-the-message-structure-to-use-with-ctrl"><a class="header" href="#schema-for-the-message-structure-to-use-with-ctrl">Schema for the message structure to use with ctrl</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Field Name</th><th>Value Type</th><th>Description</th></tr></thead><tbody>
<tr><td>toNode</td><td><code>string</code></td><td>A single node to send a message to</td></tr>
<tr><td>toNodes</td><td><code>string array</code></td><td>A comma separated list of nodes to send a message to</td></tr>
<tr><td>jetstreamToNode</td><td><code>string array</code></td><td>JetstreamToNode, the topic used to prefix the stream name with the format NODES.&lt;JetstreamToNode&gt;</td></tr>
<tr><td>method</td><td><code>string</code></td><td>The request method to use</td></tr>
<tr><td>methodArgs</td><td><code>string array</code></td><td>The arguments to use for the method</td></tr>
<tr><td>replyMethod</td><td><code>string</code></td><td>The method to use for the reply message</td></tr>
<tr><td>replyMethodArgs</td><td><code>string array</code></td><td>The arguments to use for the reply method</td></tr>
<tr><td>ACKTimeout</td><td><code>int</code></td><td>The time to wait for a received acknowledge (ACK). 0 for no acknowledge</td></tr>
<tr><td>retries</td><td><code>int</code></td><td>The number of times to retry if no ACK was received</td></tr>
<tr><td>replyACKTimeout</td><td><code>int</code></td><td>The timeout to wait for an ACK message before we retry</td></tr>
<tr><td>replyRetries</td><td><code>int</code></td><td>The number of times to retry if no ACK was received for repply messages</td></tr>
<tr><td>methodTimeout</td><td><code>int</code></td><td>The timeout in seconds for how long we wait for a method to complete</td></tr>
<tr><td>replyMethodTimeout</td><td><code>int</code></td><td>The timeout in seconds for how long we wait for a method to complete for repply messages</td></tr>
<tr><td>directory</td><td><code>string</code></td><td>The directory for where to store the data of the repply message</td></tr>
<tr><td>fileName</td><td><code>string</code></td><td>The name of the file for where we store the data of the reply message</td></tr>
<tr><td>schedule</td><td>[int type value for interval in seconds, int type value for total run time in seconds]</td><td>Schedule a message to re run at interval</td></tr>
</tbody></table>
</div>
<h2 id="more-detailed-description-of-the-fields"><a class="header" href="#more-detailed-description-of-the-fields">More detailed description of the fields</a></h2>
<pre><code class="language-yaml">toNode : "some-node"
</code></pre>
<p>The node to send the message to.</p>
<pre><code class="language-yaml">toNodes : node1,node2
</code></pre>
<p>ToNodes to specify several hosts to send message to in the form of an slice/array. When used, the message will be split up into one message for each node specified, so the sending to each node will be handled individually.</p>
<pre><code class="language-yaml">data : data here in byte format
</code></pre>
<p>The actual data in the message. This is the field where we put the returned data in a reply message. The data field are of type []byte.</p>
<pre><code class="language-yaml">method : cliCommand
</code></pre>
<p>What request method type to use, like cliCommand, httpGet, <a href="./core_request_methods.html">all methods</a>.</p>
<pre><code class="language-yaml">  methodArgs :
  - "bash"
  - "-c"
  - |
      echo "this is a test"
      echo "and some other test"
</code></pre>
<p>Additional arguments that might be needed when executing the method. Can be f.ex. an ip address if it is a tcp sender, or the actual shell command to execute in a cli.</p>
<pre><code class="language-yaml">replyMethod : file
</code></pre>
<p>ReplyMethod, is the method to use for the reply message. By default the reply method will be set to log to file, but you can override it setting your own here.</p>
<pre><code class="language-yaml">  methodArgs :
  - "bash"
  - "-c"
  - |
      echo "this is a test"
</code></pre>
<p>Additional arguments that might be needed when executing the reply method. Can be f.ex. an ip address if it is a tcp sender, or the shell command to execute in a cli session.
replyMethodArgs :</p>
<pre><code class="language-yaml">fromNode Node : "node2"
</code></pre>
<p>From what node the message originated. This field is automatically filled by ctrl when left blanc, so that when a message are sent from a node the user don't have to worry about getting eventual repply messages back.
Setting a</p>
<pre><code class="language-yaml">ACKTimeout: 10 
</code></pre>
<p>ACKTimeout for waiting for an Ack message in seconds.</p>
<p>If the ACKTimeout value is set to 0 the message will become an No Ack message. With No Ack messages we will not wait for an Ack, nor will the receiver send an Ack, and we will never try to resend a message.</p>
<pre><code class="language-yaml">retryWait : 60
</code></pre>
<p>RetryWait specifies the time in seconds to wait between retries. This value is added to the ACKTimeout and to make the total time before retrying to sending a message. A usecase can be when you want a low ACKTimeout, but you want to add more time between the retries to avoid spamming the receiving node.</p>
<pre><code class="language-yaml">retries : 3
</code></pre>
<p>How many times we should try to resend the message if no ACK was received.</p>
<pre><code class="language-yaml">replyACKTimeout int `json:"replyACKTimeout" yaml:"replyACKTimeout"`
</code></pre>
<p>The ACK timeout used with reply messages. If not specified the value of <code>ACKTimeout</code> will be used.</p>
<pre><code class="language-yaml">replyRetries int `json:"replyRetries" yaml:"replyRetries"`
</code></pre>
<p>The number of retries for trying to resend a message for reply messages.</p>
<pre><code class="language-yaml">methodTimeout : 10
</code></pre>
<p>Timeout for how long a method should be allowed to run before it is timed out.
If <code>methodTimeout : -1</code> the method will not time out.</p>
<pre><code class="language-yaml">replyMethodTimeout : 10
</code></pre>
<p>Timeout for how long a method should be allowed to run before it is timed out, but for the reply message.</p>
<pre><code class="language-yaml">directory string `json:"directory" yaml:"directory"`
</code></pre>
<p>Specify the directory structure to use when saving the result data for a repply message.</p>
<ul>
<li>When the values are comma separated like <code>"syslog","metrics"</code> a syslog folder with a subfolder metrics will be created in the directory specified with startup env variable <code>SUBSCRIBER_DATA_FOLDER</code>.</li>
<li>Absolute paths can also be used if you want to save the result somewhere else on the system, like "/etc/myservice".</li>
</ul>
<pre><code class="language-yaml">fileName : myfile.conf
</code></pre>
<p>The fileName field are used together with the directory field mentioned earlier to create a full path for where to write the resulting data of a repply message.</p>
<pre><code class="language-yaml">schedule : [2,5]
</code></pre>
<p>Schedule are used for scheduling the method of messages to be executed several times. The schedule is defined as an array of two values, where the first value defines how often the schedule should trigger a run in seconds, and the second value is for how long the schedule are allowed to run in seconds total. <code>[2,5]</code> will trigger the method to be executed again every 2 seconds, but when a total time of 5 seconds have passed it will stop scheduling.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jetstream"><a class="header" href="#jetstream">Jetstream</a></h1>
<p>ctrl takes benefit of some of the streaming features of NATS Jetstream. In short, Jetstream will keep the state of the message queues on the nats-server, whereas with normal ctrl messaging the state of all the messages are kept on and is the responsibility of the node publishing the message.</p>
<p>With Jetstream some cool posibilities with ctrl become possible. A couple of examples are:</p>
<ul>
<li>Use ctrl in a github runner, and make messages available to be consumed even after the runner have stopped.</li>
<li>Broadcast message to all nodes.</li>
</ul>
<h2 id="general-use"><a class="header" href="#general-use">General use</a></h2>
<p>To use Jetstream instead of regular NATS messaging, put the <strong>node name</strong> of the node that is supposed to consume the message in the <strong>jetstreamToNode</strong> field.</p>
<pre><code class="language-yaml">---
- toNodes:
    - mynode1
  jetstreamToNode: mynode1
  method: cliCommand
  methodArgs:
    - /bin/bash
    - -c
    - |
      tree
  methodTimeout: 3
  replyMethod: console
  ACKTimeout: 0
</code></pre>
<p>The request will then be published with NATS Jetstream to all nodes registered on the nats-server. The reply with the result will be sent back as a normal NATS message (not Jetstream).</p>
<h2 id="broadcast"><a class="header" href="#broadcast">Broadcast</a></h2>
<p>A message can be broadcasted to all nodes by using the value <strong>all</strong> with jetstreamToNode field of the message like the example below.</p>
<pre><code class="language-yaml">---
- toNodes:
    - all
  jetstreamToNode: all
  method: cliCommand
  methodArgs:
    - /bin/bash
    - -c
    - |
      tree
  methodTimeout: 3
  replyMethod: console
  ACKTimeout: 0
</code></pre>
<p>The request will then be published with NATS Jetstream to all nodes registered on the nats-server. The reply with the result will be sent back as a normal NATS message (not Jetstream).</p>
<h2 id="specify-more-subjects-to-consume-with-streams"><a class="header" href="#specify-more-subjects-to-consume-with-streams">Specify more subjects to consume with streams</a></h2>
<p>More subject can be specified by using the flag <code>jetstreamsConsume</code> or env variable <code>JETSTREAMS_CONSUME</code> .</p>
<p>Example:</p>
<pre><code class="language-env">JETSTREAMS_CONSUME=updates,restart,indreostfold
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="request-methods"><a class="header" href="#request-methods">Request Methods</a></h1>
<div class="table-wrapper"><table><thead><tr><th>Method name</th><th>Description</th></tr></thead><tbody>
<tr><td>opProcessList</td><td>Get a list of the running processes</td></tr>
<tr><td>opProcessStart</td><td>Start up a process</td></tr>
<tr><td>opProcessStop</td><td>Stop a process</td></tr>
<tr><td>cliCommand</td><td>Will run the command given, and return the stdout output of the command when the command is done</td></tr>
<tr><td>cliCommandCont</td><td>Will run the command given, and return the stdout output of the command continously while the command runs</td></tr>
<tr><td>tailFile</td><td>Tail log files on some node, and get the result for each new line read sent back in a reply message</td></tr>
<tr><td>httpGet</td><td>Scrape web url, and get the html sent back in a reply message</td></tr>
<tr><td>hello</td><td>Send Hello messages</td></tr>
<tr><td>copySrc</td><td>Copy a file from one node to another node</td></tr>
<tr><td>errorLog</td><td>Method for receiving error logs for Central error logger</td></tr>
<tr><td>none</td><td>Don't send a reply message</td></tr>
<tr><td>console</td><td>Print to stdout or stderr</td></tr>
<tr><td>fileAppend</td><td>Append to file, can also write to unix sockets</td></tr>
<tr><td>file</td><td>Write to file, can also write to unix sockets</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="ctrl_data-variable"><a class="header" href="#ctrl_data-variable">{{CTRL_DATA}} variable</a></h1>
<p>By using the <code>{{CTRL_DATA}}</code> you can grab the result output of your initial request method, and then use it as input in your reply method.</p>
<p><strong>NB:</strong> The echo command in the example below will remove new lines from the data. To also keep any new lines we need to put escaped <strong>quotes</strong> around the template variable. Like this:</p>
<ul>
<li><code>\"{{CTRL_DATA}}\"</code></li>
</ul>
<p>Example of usage:</p>
<pre><code class="language-json">[
    {
        "directory":"cli_command_test",
        "fileName":"cli_command.result",
        "toNode": "node2",
        "method":"cliCommand",
        "methodArgs": ["bash","-c","tree"],
        "replyMethod":"cliCommand",
        "replyMethodArgs": ["bash", "-c","echo \"{{CTRL_DATA}}\" &gt; apekatt.txt"],
        "replyMethodTimeOut": 10,
        "ACKTimeout":3,
        "retries":3,
        "methodTimeout": 10
    }
]
</code></pre>
<p>The above example, with steps explained:</p>
<ul>
<li>Send a message from <strong>node1</strong> to <strong>node2</strong> with a Request Method of type cliCommand.</li>
<li>When received at <strong>node2</strong> we execute the Reqest Method with the arguments specified in the methodArgs.</li>
<li>When the method on <strong>node2</strong> is done the result data of the method run will be stored in the variable {{CTRL_DATA}}. We can then use this variable when we craft the reply message method by embedding it into a new bash command.</li>
<li>The reply message is then sent back to <strong>node1</strong>, the method will be executed, and all newlines in the result data will be removed, and all the data with the new lines removed will be stored in a file called <code>apekatt.txt</code></li>
</ul>
<p>The same using bash's herestring:</p>
<pre><code class="language-json">[
    {
        "directory":"cli_command_test",
        "fileName":"cli_command.result",
        "toNode": "ship2",
        "method":"cliCommand",
        "methodArgs": ["bash","-c","tree"],
        "replyMethod":"cliCommand",
        "replyMethodArgs": ["bash", "-c","cat &lt;&lt;&lt; {{CTRL_DATA}} &gt; hest.txt"],
        "replyMethodTimeOut": 10,
        "ACKTimeout":3,
        "retries":3,
        "methodTimeout": 10
    }
]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="message-methodargs-variables"><a class="header" href="#message-methodargs-variables">Message methodArgs variables</a></h1>
<h2 id="ctrl_file"><a class="header" href="#ctrl_file">{{CTRL_FILE}}</a></h2>
<p>Read a local text file, and embed the content of the file into the methodArgs.</p>
<pre><code class="language-yaml">---
- toNodes:
    - btdev1
  #jetstreamToNode: btdev1
  method: cliCommand
  methodArgs:
    - /bin/bash
    - -c
    - |
      echo {{CTRL_FILE:/some_directory/source_file.yaml}}&gt;/other_directory/destination_file.yaml
  methodTimeout: 3
  replyMethod: console
  ACKTimeout: 0
</code></pre>
<p>The above example will before sending the message read the content of the file <code>/some_directory/source_file.yaml</code>. When the message is received at it's destination node and the cliCommand is executed the content will be written to <code>/other_directory/destination_file.yaml</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nats-timeouts"><a class="header" href="#nats-timeouts">Nats timeouts</a></h1>
<p>The various timeouts for the NATS messages can be controlled via an .env file or flags.</p>
<p>If the network media is a high latency like satellite links, it will make sense to adjust the client timeout to reflect the latency</p>
<pre><code class="language-text">  -natsConnOptTimeout int
        default nats client conn timeout in seconds (default 20)
</code></pre>
<p>The interval in seconds the nats client should try to reconnect to the nats-server if the connection is lost.</p>
<pre><code class="language-text">  -natsConnectRetryInterval int
        default nats retry connect interval in seconds. (default 10)
</code></pre>
<p>Jitter values.</p>
<pre><code class="language-text">  -natsReconnectJitter int
        default nats ReconnectJitter interval in milliseconds. (default 100)
  -natsReconnectJitterTLS int
        default nats ReconnectJitterTLS interval in seconds. (default 5)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="startup-folder"><a class="header" href="#startup-folder">Startup folder</a></h1>
<p>Messages can be automatically scheduled to be read and executed at startup of ctrl.</p>
<p>A folder named <strong>startup</strong> will be present in the working directory of ctrl. To inject messages at startup, put them here.</p>
<p>Messages put in the startup folder will not be sent to the broker but handled locally, and only (eventually) the reply message from the Request Method called will be sent to the broker.</p>
<p>This can be really handy when you have some 1-off job you want to done at startup, like some cleaning up.</p>
<h2 id="example-reqest-metrics-from-nodes"><a class="header" href="#example-reqest-metrics-from-nodes">Example reqest metrics from nodes</a></h2>
<p>Another example could be that you have some local prometheus metrics you want to scrape every 5 minutes, and you want to send them to some central metrics system.</p>
<pre><code class="language-yaml">---
- toNodes:
    - ["node1","node2"]
  method: httpGet
  methodArgs:
    - "http://localhost:8080/metrics"
  replyMethod: file
  methodTimeout: 5
  directory: metrics
  fileName: metrics.html
  schedule : [120,999999999]
</code></pre>
<p>The example above will send out a request to node1 and node2 every 120 second to scrape the metrics and write the results that came back to a folder named <strong>data/metrics</strong> in the current running directory.</p>
<h2 id="example-read-metrics-locally-first-and-then-send-to-remote-node"><a class="header" href="#example-read-metrics-locally-first-and-then-send-to-remote-node">Example read metrics locally first, and then send to remote node</a></h2>
<p>But we can also make the nodes publish their metrics instead of requesting it by putting a message in each nodes startup folder, set the <strong>toNode</strong> field to local, and instead use the <strong>fromNode</strong> field to decide where to deliver the result.</p>
<pre><code class="language-yaml">---
- toNodes:
    - ["local"]
  fromNode: my-metrics-node
  method: httpGet
  methodArgs:
    - "http://localhost:8080/metrics"
  replyMethod: file
  methodTimeout: 5
  directory: metrics
  fileName: metrics.html
  schedule : [120,999999999]
</code></pre>
<p>In the above example, the httpGet will be run on the local node, and the result will be sent to my-metrics-node.</p>
<h3 id="how-to-send-the-reply-to-another-node-further-explained"><a class="header" href="#how-to-send-the-reply-to-another-node-further-explained">How to send the reply to another node further explained</a></h3>
<p>Normally the <strong>fromNode</strong> field is automatically filled in with the node name of the node where a message originated. Since messages within the startup folder is not received from another node via the normal message path we need set the <strong>fromNode</strong> field in the message to where we want the reply (result) delivered.</p>
<p>As an example. If You want to place a message on the startup folder of <strong>node1</strong> and send the result to <strong>node2</strong>. Specify <strong>node2</strong> as the <strong>fromNode</strong>, and <strong>node1</strong> as the <strong>toNode</strong></p>
<h4 id="use-local-as-the-tonode-nodename"><a class="header" href="#use-local-as-the-tonode-nodename">Use local as the toNode nodename</a></h4>
<p>Since messages used in startup folder are ment to be delivered locally we can simplify things a bit by setting the <strong>toNode</strong> field value of the message to <strong>local</strong>.</p>
<pre><code class="language-json">[
    {
        "toNode": "local",
        "fromNode": "central",
        "method": "cliCommand",
        "methodArgs": [
            "bash",
            "-c",
            "curl localhost:2111/metrics"
        ],
        "replyMethod": "console",
        "methodTimeout": 10
    }
]

</code></pre>
<p>This example message will be read at startup, and executed on the local node where it was read, the method will be executed, and the result of the method will be sent to <strong>central</strong>. This is basically the same as the previous example, but we're using cliCommand method with curl instead of the httpGet method.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="errors"><a class="header" href="#errors">Errors</a></h1>
<p>Errors happening on <strong>all</strong> nodes will be reported back to the node(s) started with the flag <code>-isCentralErrorLogger</code> set to true, or by using the <code>IS_CENTRAL_ERROR_LOGGER</code> env variable.</p>
<h2 id="log-level"><a class="header" href="#log-level">Log level</a></h2>
<p>The log level can also be specified with the <code>LOG_LEVEL</code> env variable. Values are <code>error/info/warning/debug/none</code>.</p>
<h2 id="debug"><a class="header" href="#debug">Debug</a></h2>
<p>To get more debug information in the logs printed to STDERR the env variable <code>ENABLE_DEBUG</code> can be set to true. This will not affect the information printed to the log files, only to STDERR.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="central-1"><a class="header" href="#central-1">central</a></h1>
<p>To get functionality like central audit log, signing keys, authorization with ACL's and hello messages one node should be started with the node name <strong>central</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-messages"><a class="header" href="#hello-messages">Hello messages</a></h1>
<p>All nodes can send hello messages to inform that they are up. The interval between sending a hello message can be set with the <code>START_PUB_HELLO</code> environment variable.</p>
<p>Hello messages are sent to the node with the name <strong>central</strong>. When a hello message are received on central, information with the time and node name will be stored in the <strong>ctrl data folder</strong></p>
<h2 id="public-keys"><a class="header" href="#public-keys">Public keys</a></h2>
<p>ctrl nodes can use ed25519 keys for signing messages, so each ctrl instance will generate a public and private key pair on startup. The public keys are sent to the central server with the hello messages.</p>
<p>To read more about signing keys here: <a href="./core_signing_keys.html">signing keys</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="signing-keys"><a class="header" href="#signing-keys">signing keys</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="acl"><a class="header" href="#acl">ACL</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="audit-log"><a class="header" href="#audit-log">audit log</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="httpget"><a class="header" href="#httpget">httpGet</a></h1>
<p>In JSON.</p>
<pre><code class="language-json">[
    {
        "directory": "httpget",
        "fileName": "finn.no.html",
        "toNodes": ["node1","node2"],
        "method":"httpGet",
        "methodArgs": ["https://finn.no"],
        "replyMethod":"file",
        "ACKTimeout":5,
        "retries":3,
        "methodTimeout": 5
    }
]
</code></pre>
<p>In YAML.</p>
<pre><code class="language-yaml">---
- toNodes:
    - ["node1","node2"]
  method: httpGet
  methodArgs:
    - "https://finn.no"
  replyMethod: file
  ACKTimeout: 5
  retries: 3
  methodTimeout: 5
  directory: httpget
  fileName: finn.no.html
</code></pre>
<p>The result html file of the http get will be written to:</p>
<ul>
<li>&lt;data folder&gt;\httpget\node1\finn.no.html</li>
<li>&lt;data folder&gt;\httpget\node2\finn.no.html</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tailfile"><a class="header" href="#tailfile">tailFile</a></h1>
<p>In JSON.</p>
<pre><code class="language-json">[
    {
        "directory": "tails",
        "fileName": "some.log",
        "toNodes": "node1","node2","node3",
        "method":"tailFile",
        "methodArgs": ["/var/log/syslog"],
        "ACKTimeout":5,
        "retries":3,
        "methodTimeout": 200
    }
]
</code></pre>
<p>NB: If no replyMethod are specified, it will default to <strong>file</strong></p>
<p>In YAML.</p>
<pre><code class="language-yaml">---
- toNodes:
    - ["node1","node2","node3"]
  method: tailFile
  methodArgs:
    - "/var/log/syslog"
  replyMethod: file
  ACKTimeout: 5
  retries: 3
  methodTimeout: 5
  directory: tails
  fileName: var_log_syslog.log
</code></pre>
<p>The above example will tail the syslog file on 3 nodes for 5 seconds, and save the result on the node where the request came from in the local <code>data</code> folder.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clicommand"><a class="header" href="#clicommand">cliCommand</a></h1>
<p>With <strong>cliCommand</strong> you specify the command to run in <strong>methodArgs</strong> prefixed with the interpreter to use, for example with bash <strong>bash</strong> <code>"bash","-c","tree"</code>.</p>
<p>On Linux and Darwin, the shell interpreter can also be auto detected by setting the value of <strong>useDetectedShell</strong> in the message to <strong>true</strong>. If set to true the methodArgs only need a single string value with command to run. Example below.</p>
<pre><code class="language-yaml">---
- toNodes:
    - node2
  useDetectedShell: true
  method: cliCommand
  methodArgs:
    - |
      rm -rf ./data &amp; systemctl restart ctrl

  replyMethod: fileAppend
  ACKTimeout: 30
  retries: 1
  ACKTimeout: 30
  directory: system
  fileName: system.log
</code></pre>
<h2 id="example-in-json"><a class="header" href="#example-in-json">Example in JSON</a></h2>
<pre><code class="language-json">[
    {
        "directory":"system",
        "fileName":"system.log",
        "toNodes": ["node2"],
        "method":"cliCommand",
        "methodArgs": ["bash","-c","rm -rf ./data &amp; systemctl restart ctrl"],
        "replyMethod":"fileAppend",
        "ACKTimeout":30,
        "retries":1,
        "methodTimeout": 30
    }
]
</code></pre>
<h2 id="example-in-yaml"><a class="header" href="#example-in-yaml">Example in YAML</a></h2>
<p>In YAML.</p>
<pre><code class="language-yaml">---
- toNodes:
    - node2
  method: cliCommand
  methodArgs:
    - "bash"
    - "-c"
    - |
      rm -rf ./data &amp; systemctl restart ctrl

  replyMethod: fileAppend
  ACKTimeout: 30
  retries: 1
  ACKTimeout: 30
  directory: system
  fileName: system.log
</code></pre>
<p>Will send a message to node2 to delete the ctrl data folder, and then restart ctrl. The end result will be appended to the specified file on the node where the request originated.</p>
<h2 id="more-examples"><a class="header" href="#more-examples">More examples</a></h2>
<h3 id="get-the-prometheus-metrics-of-the-central-server"><a class="header" href="#get-the-prometheus-metrics-of-the-central-server">Get the prometheus metrics of the central server</a></h3>
<pre><code class="language-json">[
    {
        "toNode": "central",
        "method": "cliCommand",
        "methodArgs": [
            "bash",
            "-c",
            "curl localhost:2111/metrics"
        ],
        "replyMethod": "console",
        "methodTimeout": 10
    }
]

</code></pre>
<h3 id="start-up-a-tcp-listener-for-number-of-seconds"><a class="header" href="#start-up-a-tcp-listener-for-number-of-seconds">Start up a tcp listener for number of seconds</a></h3>
<pre><code class="language-json">[
    {
        "toNode": "node1",
        "method": "cliCommandCont",
        "methodArgs": [
            "bash",
            "-c",
            "nc -lk localhost 8888"
        ],
        "replyMethod": "toConsole",
        "methodTimeout": 10,
    }
]
</code></pre>
<p>The netcat tcp listener will run for 10 seconds before the method timeout kicks in and ends the process.</p>
<h3 id="get-the-running-docker-containers-from-a-node"><a class="header" href="#get-the-running-docker-containers-from-a-node">Get the running docker containers from a node</a></h3>
<pre><code class="language-json">[
    {
        "directory":"some/cli/command",
        "fileName":"cli.result",
        "toNode": "node2",
        "method":"cliCommand",
        "methodArgs": ["bash","-c","docker ps -a"],
        "replyMethod":"fileAppend",
    }
]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clicommandcont"><a class="header" href="#clicommandcont">cliCommandCont</a></h1>
<p>The <strong>cliCommand</strong> and the <strong>cliCommandCont</strong> are the same, except for one thing. <strong>cliCommand</strong> will wait until wether the method is finished or the methodTimeout kicks in to send the result as one single message. <strong>cliCommand</strong> will when a line is given to  either stdout or stderr create messages with that single line in the data field, and send it back to the node where the message originated.</p>
<pre><code class="language-json">[
    {
        "directory":"some/cli/command",
        "fileName":"cli.result",
        "toNode": "node2",
        "method":"cliCommandCont",
        "methodArgs": ["bash","-c","tcpdump -nni any port 8080"],
        "replyMethod":"fileAppend",
        "methodTimeout":10,
    }
]
</code></pre>
<p>Example Will run the command given for 10 seconds (methodTimeout), and return the stdout output of the command continously while the command runs. Uses the methodTimeout to define for how long the command will run.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="copysrc"><a class="header" href="#copysrc">copySrc</a></h1>
<p>Copy a file from one node to another node.</p>
<pre><code class="language-json">[
    {
        "directory": "copy",
        "fileName": "copy.log",
        "toNodes": ["central"],
        "method":"copySrc",
        "methodArgs": ["./testbinary","ship1","./testbinary-copied","500000","20","0770"],
        "methodTimeout": 10,
        "replyMethod":"console"
    }
]
</code></pre>
<ul>
<li>toNode/toNodes, specifies what node to send the request to, and which also contains the src file to copy.</li>
<li>methodArgs, are split into several fields, where each field specifies:
<ol>
<li>SrcFullPath, specifies the full path including the name of the file to copy.</li>
<li>DstNode, the destination node to copy the file to.</li>
<li>DstFullPath, the full path including the name of the destination file. The filename can be different than the original name.</li>
<li>SplitChunkSize, the size of the chunks to split the file into for transfer.</li>
<li>MaxTotalCopyTime, specifies the maximum allowed time the complete copy should take. Make sure you set this long enough to allow the transfer to complete.</li>
<li>FolderPermission, the permissions to set on the destination folder if it does not exist and needs to be created. Will default to 0755 if no value is set.</li>
</ol>
</li>
</ul>
<p>To copy from a remote node to the local node, you specify the remote nodeName in the toNode field, and the message will be forwarded to the remote node. The copying request will then be picked up by the remote node's <strong>copySrc</strong> handler, and the copy session will then be handled from the remote node.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="send-more-messages"><a class="header" href="#send-more-messages">Send more messages</a></h1>
<pre><code class="language-json">[
    {
        "directory":"cli-command-executed-result",
        "fileName": "some.log",
        "toNode": "ship1",
        "method":"cliCommand",
        "methodArgs": ["bash","-c","sleep 3 &amp; tree ./"],
        "ACKTimeout":10,
        "retries":3,
        "methodTimeout": 4
    },
    {
        "directory":"cli-command-executed-result",
        "fileName": "some.log",
        "toNode": "ship2",
        "method":"cliCommand",
        "methodArgs": ["bash","-c","sleep 3 &amp; tree ./"],
        "ACKTimeout":10,
        "retries":3,
        "methodTimeout": 4
    }
]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ctrl-as-github-action-runner"><a class="header" href="#ctrl-as-github-action-runner">ctrl as github action runner</a></h1>
<p>Run ctrl as a docker container in a github workflow. This can for example be as part of a CI/CD pipeline, or for content versioning.</p>
<p>This howto will show the steps involved to get ctrl up and running as Github Action Runner. First we start with setting up a NATS Server, we then setup the local ctrl node <strong>node1</strong>, and then the node that will be started as a Github Action Runner.</p>
<p>This howto assumes that you have a nats-server setup, and at least one ctrl node instance up running. How to setup a <strong>nats-server</strong> and a <strong>ctrl node</strong> on a computer/server can be found in the <strong>User Guides</strong> section of the documentation.</p>
<p>In the examples below I've used the name <strong>node1</strong> as an example for the node that will receive the message when the github repository are updated.</p>
<h2 id="github-action-runner-setup"><a class="header" href="#github-action-runner-setup">Github Action Runner setup</a></h2>
<p>Create a Github repository.</p>
<p>Clone the repository down to your local machine or other.</p>
<pre><code class="language-bash">git clone &lt;my-repo-name&gt; &amp;&amp; cd my-repo-name
</code></pre>
<p>Create a github workflows folder</p>
<pre><code class="language-bash">mkdir -p .github/workflows
</code></pre>
<p>Create a <code>workflow.yaml</code> in the new directory with the following content.</p>
<pre><code class="language-yaml">name: GitHub Actions Demo
run-name: ${{ github.actor }} is testing out GitHub Actions 🚀
on: [push]

jobs:
  send-message:
    name: send-message
    runs-on: ubuntu-latest

    services:
      ctrl:
        image: postmannen/ctrl:amd64-0.03
        env:
          NKEY_SEED: ${{ secrets.SEED }}
          NODE_NAME: "github"
          BROKER_ADDRESS: "&lt;REPLACE WITH ip address of the NATS broker here&gt;:4222"
          ENABLE_KEY_UPDATES: 0
          ENABLE_ACL_UPDATES: 0
        volumes:
          # mount the readfolder where we put the message to send.
          - ${{ github.workspace }}/readfolder:/app/readfolder
          # mount the files folder from the repo to get the file
          # to inject into the message.
          - ${{ github.workspace }}/files:/app/files
        options: --name ctrl

    steps:
      # When the container was started the repo was not yeat available since it was not
      # the workspace at that time. We want to make the /files mount to point to the
      # folder in the repo. Checkout the git repo, and restart the docker container so
      # it will mount the directories from the repo which now is the current github.workspace.
      - name: checkout repo
        uses: actions/checkout@v4
      - name: restart docker
        uses: docker://docker
        with:
          args: docker restart ctrl
      - run: sudo chmod 777 ${{ github.workspace }}/readfolder
      - run: sleep 3
      # Send the message by moving it to the readfolder.
      - run: mv ${{ github.workspace }}/message.yaml ${{ github.workspace }}/readfolder
      - run: &gt;
          sleep 5 &amp;&amp; tree
</code></pre>
<h2 id="define-nkey-as-github-secret"><a class="header" href="#define-nkey-as-github-secret">Define NKEY as github secret</a></h2>
<p>In your repository, go to <strong>Settings-&gt;Secrets And Variables-&gt;Actions</strong> and press <strong>New Repository Secret</strong>. Give the new secret the name <strong>SEED</strong>, and put the content of the seed into <strong>Secret</strong>. This is the seed that we referenced earlier in the github action workflow.</p>
<h2 id="define-message-with-command-to-send"><a class="header" href="#define-message-with-command-to-send">Define message with command to send</a></h2>
<p>We want to send a message from the Github Action, so we need to specify the content of the message to use.</p>
<p>In the root folder of the github folder create a <strong>message.yaml</strong> file, and fill in the following content:</p>
<pre><code class="language-yaml">---
- toNodes:
    - node1
  method: cliCommand
  methodArgs:
    - "bash" # Change from bash to ash for alpine containers
    - "-c"
    - |
      echo '{{CTRL_FILE:./files/file.txt}}'&gt;file.txt

  replyMethod: none
  ACKTimeout: 0
</code></pre>
<p>The message references a file with the <code>{{CTRL_FILE:&lt;file path&gt;}}</code> to use with the cli command found in the <code>files</code> folder. The file referenced will be embedded into the methodArgs defined in the message.</p>
<p>From the repository folder run the following commands:</p>
<pre><code class="language-bash">mkdir -p files
echo "some cool text to put as file content.........." &gt; files/file.txt
</code></pre>
<p>The example tries to show how we can get the message to run a shell/cli command on node1 at delivery. The shell command will use the content of the file located at <code>&lt;repo&gt;/files/file.txt</code>, and create a file called <strong>file.txt</strong> in the ctrl working directory on <strong>node1</strong>.</p>
<h2 id="update-the-repository-and-send-message-with-command"><a class="header" href="#update-the-repository-and-send-message-with-command">Update the repository and send message with command</a></h2>
<p>Commit the changes of the repository. If you check the <strong>Actions</strong> section of the new repo you should see that a an action have started.</p>
<p>When the action is done, you should have received a file called <strong>file.txt</strong> in the ctrl working directory on <strong>node1</strong>, with the content you provided in <strong>text.txt</strong>.</p>
<h2 id="other-cool-things-you-can-do--like-deploy-kubernetes-manifests"><a class="header" href="#other-cool-things-you-can-do--like-deploy-kubernetes-manifests">Other cool things you can do ... like deploy kubernetes manifests</a></h2>
<p>Replace the the bash command specified in the method arguments with a kubetctl command like this:</p>
<pre><code class="language-yaml">---
- toNodes:
    - node1
  method: cliCommand
  methodArgs:
    - "bash" # Change from bash to ash for alpine containers
    - "-c"
    - |
      kubectl apply -f '{{CTRL_FILE:./files/mydeployment.yaml}}'

  replyMethod: none
  ACKTimeout: 0
</code></pre>
<p>Create a new file in the <code>&lt;repo&gt;/files</code> folder named <strong>mydeployment.yaml</strong>.</p>
<p>Commit the changes to the repo, and the deployment should be executed if you have a kubernetes instance running on <strong>node1</strong>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ctrl-as-prometheus-collector"><a class="header" href="#ctrl-as-prometheus-collector">ctrl as prometheus collector</a></h1>
<p>ctrl can be used to collect collect metrics from various systems. It can for example scrape/read some defined metrics with one node, and deliver the result to another node where you can expose the metrics directly using ctrl's builtin http server, or you could for example inject the metrics data to some database if that is desired. It is totally up to you.</p>
</style>
</head>
<body>
<p align="center"><img src="https://github.com/postmannen/ctrl/blob/main/doc/usecase-prometheus-collector.svg?raw=true" /></p>
</body>
<p>The example that follows will scrape prometheus metrics with two ctrl nodes, deliver them to a third node called <strong>metrics</strong>, and expose them with the builtin http server. Prometheus can then be used to read all the metrics from the various nodes on the <strong>metrics</strong> node.</p>
<p>Before you start, make sure to read the <strong>User Guides</strong> section for how to start up a NATS broker, and for general information about setting up ctrl.</p>
<h2 id="node-setup"><a class="header" href="#node-setup">Node Setup</a></h2>
<h3 id="central-node"><a class="header" href="#central-node">central node</a></h3>
<p>Start up a ctrl node named <strong>central</strong> that will serve as central for audit logs and other system logs happening with the ctrl nodes. Example of .env file to use.</p>
<pre><code class="language-env">NODE_NAME=central
BROKER_ADDRESS=localhost:4222
LOG_LEVEL=info
START_PUB_HELLO=60
IS_CENTRAL_ERROR_LOGGER=true
</code></pre>
<h3 id="collected-metrics-node"><a class="header" href="#collected-metrics-node">collected metrics node</a></h3>
<p>Start up a node named <strong>metrics</strong> that will serve as the central place where we deliver all the metrics. On this node we expose ctrl's data folder over http. Example .env file below.</p>
<pre><code class="language-env">NODE_NAME=metrics
BROKER_ADDRESS=localhost:4222
LOG_LEVEL=info
START_PUB_HELLO=60
EXPOSE_DATA_FOLDER=localhost:6060
</code></pre>
<h3 id="metrics-collector-nodes"><a class="header" href="#metrics-collector-nodes">metrics collector nodes</a></h3>
<h4 id="prometheus-node-exporter"><a class="header" href="#prometheus-node-exporter">prometheus node exporter</a></h4>
<p>If don't yet have any metrics to collect, you can start up <a href="https://github.com/prometheus/node_exporter">prometheus node_exporter</a> to get some local system metrics.</p>
<h4 id="collector-node-setup"><a class="header" href="#collector-node-setup">collector node setup</a></h4>
<p>The following configuration file can be used on all nodes, but for each node started replace with a unique <strong>NODE_NAME</strong>, eg. <strong>node1</strong> and <strong>node2</strong>.</p>
<pre><code class="language-env">NODE_NAME=node1     #give each node a unique node name
BROKER_ADDRESS=localhost:4222
LOG_LEVEL=info
START_PUB_HELLO=60
</code></pre>
<p>Create 2-3 (node1,node2,node3) nodes which will be the nodes that scrape some metrics on some host.</p>
<h5 id="startup-folder-1"><a class="header" href="#startup-folder-1">Startup folder</a></h5>
<p>Each ctrl instance started will have a <strong>startup</strong> folder in it's running directory. Messages in the startup folder will be read at startup, and handled by ctrl.</p>
<p>We can use the <strong>schedule</strong> field in the message to make ctrl rerun the method of the message at a scheduled interval.</p>
<p>Put the following message in the <strong>startup</strong> folder on all the nodes that will collect metrics.</p>
<pre><code class="language-yaml">---
- toNodes:
    # Deliver the message locally
    - local
  # Set the node where we send the reply with the result
  fromNode: metrics
  method: httpGet
  methodArgs:
    - http://localhost:9100/metrics
  # Write the result to a file on the fromNode
  replyMethod: file
  # The directory which we want to write the result in
  directory: nodeexporters
  # The filename we want to write the result to
  fileName: metrics.html
  # Schedule rerun of the method every 30 second, for 999999999 seconds.
  schedule: [30,999999999]
</code></pre>
<h2 id="check-the-collected-metrics"><a class="header" href="#check-the-collected-metrics">Check the collected metrics</a></h2>
<p>When all nodes are started, they should start to send metrics to the <strong>metrics</strong> node. We can see the result by using curl on the node named <strong>metrics</strong>.</p>
<pre><code class="language-bash">http://localhost:6060/nodeexporters/node1/metrics.html
http://localhost:6060/nodeexporters/node2/metrics.html
</code></pre>
<p>If you want to do something further with this example you can install prometheus on the <strong>metrics</strong> node, and direct it to collect read the metrics from the various folders via the url's above.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
