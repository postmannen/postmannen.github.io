<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ctrl</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ctrl</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">introduction</a></h1>
<p>ctrl is a Command &amp; Control (C2) backend system for Servers, IOT and Edge platforms. Simply put, control anything.</p>
<p>Example use cases:</p>
<ul>
<li>Send shell commands or scripts to control one or many end nodes that will instruct to change config, restart services and control those systems.</li>
<li>Gather data from both secure and not secure devices and systems, and transfer them encrypted in a secure way over the internet to your central system for handling those data.</li>
<li>Collect metrics or monitor end nodes, then send and store the result to some ctrl instance, or pass those data's on to another ctrl instance for further handling of metrics or monitoring data.</li>
<li>Distribute certificates.</li>
<li>Run as a sidecar in Kubernetes for direct access to the pod.</li>
</ul>
<p>As long as you can do something as an operator in a shell on a system you can do the same with ctrl in a secure and encrypted way to one or all end nodes (servers) in one go with one single message/command.</p>
<p>Ctrl is a system control tool that uses NATS as its messaging architecture. It allows you to send commands using request methods which are then executed on servers. If a receiving node is down, messages are retried based on the criteria set in their body. The results of these methods are delivered back to the
sender.</p>
<p>Ctrl is designed for concurrent processing and can handle multiple messages independently, even if some processes are slow or fail. It's compatible with various host OSs and systems including cloud containers, Raspberry Pi, and others with an installed operating system. Ctrl supports most major architectures such as x86, amd64, arm64, ppc64, and can run on operating systems like Linux, OSX, Windows.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="install-with-docker"><a class="header" href="#install-with-docker">Install with docker</a></h1>
<p>Start up a local nats message broker</p>
<pre><code class="language-bash">docker run -p 4444:4444 nats -p 4444
</code></pre>
<p>Create a ctrl docker image.</p>
<pre><code class="language-bash">git clone git@github.com:postmannen/ctrl.git
cd ctrl
docker build -t ctrl:test1 .
</code></pre>
<p>Create a folder which will be the working directory for the node. This is where we keep the .env file, and can mount local host folders to folders within the container.</p>
<pre><code class="language-bash">mkdir -p testrun/readfolder
cd testrun
</code></pre>
<p>create a .env file</p>
<pre><code class="language-bash">cat &lt;&lt; EOF &gt; .env
NODE_NAME="node1"
BROKER_ADDRESS="127.0.0,1:4444"
ENABLE_DEBUG=1
START_PUB_REQ_HELLO=60
IS_CENTRAL_ERROR_LOGGER=0
EOF
</code></pre>
<p>Start the ctrl container. To be able to send messages into ctrl we mount the readfolder to a local directory. When we later got a messages to send we just copy it into the read folder and ctrl will pick it up and handle it. Messages can be in either YAML or JSON format.</p>
<pre><code class="language-bash">docker run --env-file=".env" --rm -ti -v $(PWD)/readfolder:/app/readfolder ctrl:test1
</code></pre>
<p>Prepare and send a message.</p>
<pre><code class="language-yaml">cat &lt;&lt; EOF &gt; msg.yaml
---
- toNodes:
    - node1
  method: REQCliCommand
  methodArgs:
    - "bash"
    - "-c"
    - |
      echo "some config line" &gt; /etc/my-service-config.1
      echo "some config line" &gt; /etc/my-service-config.2
      echo "some config line" &gt; /etc/my-service-config.3
      systemctl restart my-service

  replyMethod: REQNone
  ACKTimeout: 0
EOF

cp msg.yaml readfolder
</code></pre>
<p>With the above message we send to ourselves since we only got 1 node running. To start up more nodes repeat the above steps, replace the node name under <code>toNodes</code> with new names for new nodes.
NB: If more nodes share the same name the requests will be loadbalanced between them round robin.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="install-on-a-host"><a class="header" href="#install-on-a-host">Install on a host</a></h1>
<p>Start up a local nats message broker if you don't already have one.</p>
<pre><code class="language-bash">docker run -p 4444:4444 nats -p 4444
</code></pre>
<p>Build the ctrl binary from the source code.</p>
<pre><code class="language-bash">git clone git@github.com:postmannen/ctrl.git
cd cmd/ctrl
go run build
</code></pre>
<p>Copy the binary to <code>/usr/local</code>.</p>
<pre><code class="language-bash">mkdir -p /usr/local/ctrl
cp ./ctrl /usr/local/ctrl
</code></pre>
<pre><code class="language-bash">
For testing we create a folder for the node to store it's data.

```bash
cd /usr/local/ctrl
mkdir node1
cd node1
</code></pre>
<p>ctrl will create all the folders needed like etc, var and more in the current directory where it was started if they don't already exist. This behaviour can be changed with flags or env variables.</p>
<p>Create a .env file for the startup options. Flags can also be used.</p>
<pre><code class="language-bash">cat &lt;&lt; EOF &gt; .env
NODE_NAME="node1"
BROKER_ADDRESS="127.0.0,1:4444"
ENABLE_DEBUG=1
START_PUB_REQ_HELLO=60
IS_CENTRAL_ERROR_LOGGER=0
EOF
</code></pre>
<p>Start up ctrl. ctrl will automatically used the local .env file we created.</p>
<pre><code class="language-bash">../usr/local/ctrl/ctrl
</code></pre>
<p>If you open another window, and go to the <code>/usr/local/ctrl/node1</code> you should see that ctrl have created the directory structure for you with ./etc, ./var, ./directoryfolder and so on.</p>
<p>Prepare and send a message. We send messages by copying them into the ./readfolder where ctrl automatically will pick it up, and process it.</p>
<pre><code class="language-yaml">cat &lt;&lt; EOF &gt; msg.yaml
---
- toNodes:
    - node1
  method: REQCliCommand
  methodArgs:
    - "bash"
    - "-c"
    - |
      echo "some config line" &gt; /etc/my-service-config.1
      echo "some config line" &gt; /etc/my-service-config.2
      echo "some config line" &gt; /etc/my-service-config.3
      systemctl restart my-service

  replyMethod: REQNone
  ACKTimeout: 0
EOF

cp msg.yaml readfolder
</code></pre>
<p>With the above message we send to ourselves since we only got 1 node running. To start up more nodes repeat the above steps, replace.</p>
<h2 id="run-as-service"><a class="header" href="#run-as-service">Run as service</a></h2>
<p>Create a systemctl unit file to run ctrl as a service on the host</p>
<pre><code class="language-bash">progName="ctrl"
systemctlFile=/etc/systemd/system/$progName.service

cat &gt;$systemctlFile &lt;&lt;EOF
[Unit]
Description=http-&gt;${progName} service
Documentation=https://github.com/postmannen/ctrl
After=network-online.target nss-lookup.target
Requires=network-online.target nss-lookup.target

[Service]
ExecStart=env CONFIG_FOLDER=/usr/local/${progName}/etc /usr/local/${progName}/${progName}

[Install]
WantedBy=multi-user.target
EOF

systemctl enable $progName.service &amp;&amp;
systemctl start $progName.service
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="messaging"><a class="header" href="#messaging">Messaging</a></h1>
<p>The handling of all messages is done by spawning up a process for handling the message in it's own thread. This allows us to keep the state of each <strong>individual message level</strong>  both in regards to ACK's, error handling, send retries, and reruns of methods for a message if the first run was not successful.</p>
<p>All messages processed by a publisher will be written to a log file after they are processed, with all the information needed to recreate the same message if needed, or it can be used for auditing.</p>
<p>All handling down to the process and message level are handled concurrently. So if there are problems handling one message sent to a node on a subject it will not affect the messages being sent to other nodes, or other messages sent on other subjects to the same host.</p>
<p>Message types of both <strong>ACK</strong> and <strong>NACK</strong>, so we can decide if we want or don't want an Acknowledge if a message was delivered succesfully.
Example: We probably want an <strong>ACK</strong> when sending some <strong>REQCLICommand</strong> to be executed, but we don't care for an acknowledge <strong>NACK</strong> when we send an <strong>REQHello</strong> event.
If a message are <strong>ACK</strong> or <strong>NACK</strong> type are defined by the value of the <strong>ACKTimeout</strong> for each individual message:</p>
<ul>
<li><strong>ACKTimeout</strong> set to 0 will make the message become a <strong>NACK</strong> message.</li>
<li><strong>ACKTimeout</strong> set to &gt;=1 will make the message become an <strong>ACK</strong> message.</li>
</ul>
<p>If ACK is expected, and not received, then the message will be retried the amount of time defined in the <strong>retries</strong> field of a message. If numer of retries are reached, and still no ACK received, the message will be discared, and a log message will be sent to the log server.</p>
<p>To make things easier, all timeouts used for messages can be set with env variables or flags at startup of ctrl. Locally specified timeout directly in a message will override the startup values, and can be used for more granularity when needed.</p>
<h2 id="example-of-message-flow"><a class="header" href="#example-of-message-flow">Example of message flow:</a></h2>
<style>
img {
  background-color: #FFFFFF;
}
</style>
</head>
<body>
<p align="center"><img src="https://github.com/postmannen/ctrl/blob/main/doc/message-flow.svg?raw=true" /></p>
</body>
<div style="break-before: page; page-break-before: always;"></div><h1 id="message-fields"><a class="header" href="#message-fields">Message fields</a></h1>
<pre><code class="language-yaml">toNode : "some-node"
</code></pre>
<p>The node to send the message to.</p>
<pre><code class="language-yaml">toNodes : node1,node2
</code></pre>
<p>ToNodes to specify several hosts to send message to in the form of an slice/array. When used, the message will be split up into one message for each node specified, so the sending to each node will be handled individually.</p>
<pre><code class="language-yaml">data : data here in byte format
</code></pre>
<p>The actual data in the message. This is the field where we put the returned data in a reply message. The data field are of type []byte.</p>
<pre><code class="language-yaml">method : REQCliCommand
</code></pre>
<p>What request method type to use, like REQCliCommand, REQHttpGet..</p>
<pre><code class="language-yaml">  methodArgs :
  - "bash"
  - "-c"
  - |
      echo "this is a test"
      echo "and some other test"
</code></pre>
<p>Additional arguments that might be needed when executing the method. Can be f.ex. an ip address if it is a tcp sender, or the actual shell command to execute in a cli.</p>
<pre><code class="language-yaml">replyMethod : REQToFile
</code></pre>
<p>ReplyMethod, is the method to use for the reply message. By default the reply method will be set to log to file, but you can override it setting your own here.</p>
<pre><code class="language-yaml">  methodArgs :
  - "bash"
  - "-c"
  - |
      echo "this is a test"
</code></pre>
<p>Additional arguments that might be needed when executing the reply method. Can be f.ex. an ip address if it is a tcp sender, or the shell command to execute in a cli session.
replyMethodArgs :</p>
<pre><code class="language-yaml">fromNode Node : "node2"
</code></pre>
<p>From what node the message originated. This field is automatically filled by ctrl when left blanc, so that when a message are sent from a node the user don't have to worry about getting eventual repply messages back.
Setting a</p>
<pre><code class="language-yaml">ACKTimeout: 10 
</code></pre>
<p>ACKTimeout for waiting for an Ack message in seconds.</p>
<p>If the ACKTimeout value is set to 0 the message will become an No Ack message. With No Ack messages we will not wait for an Ack, nor will the receiver send an Ack, and we will never try to resend a message.</p>
<pre><code class="language-yaml">retryWait : 60
</code></pre>
<p>RetryWait specifies the time in seconds to wait between retries. This value is added to the ACKTimeout and to make the total time before retrying to sending a message. A usecase can be when you want a low ACKTimeout, but you want to add more time between the retries to avoid spamming the receiving node.</p>
<pre><code class="language-yaml">retries : 3
</code></pre>
<p>How many times we should try to resend the message if no ACK was received.</p>
<pre><code class="language-yaml">replyACKTimeout int `json:"replyACKTimeout" yaml:"replyACKTimeout"`
</code></pre>
<p>The ACK timeout used with reply messages. If not specified the value of <code>ACKTimeout</code> will be used.</p>
<pre><code class="language-yaml">replyRetries int `json:"replyRetries" yaml:"replyRetries"`
</code></pre>
<p>The number of retries for trying to resend a message for reply messages.</p>
<pre><code class="language-yaml">methodTimeout : 10
</code></pre>
<p>Timeout for how long a method should be allowed to run before it is timed out.</p>
<pre><code class="language-yaml">replyMethodTimeout : 10
</code></pre>
<p>Timeout for how long a method should be allowed to run before it is timed out, but for the reply message.</p>
<pre><code class="language-yaml">directory string `json:"directory" yaml:"directory"`
</code></pre>
<p>Specify the directory structure to use when saving the result data for a repply message.</p>
<ul>
<li>When the values are comma separated like <code>"syslog","metrics"</code> a syslog folder with a subfolder metrics will be created in the directory specified with startup env variable <code>SUBSCRIBER_DATA_FOLDER</code>.</li>
<li>Absolute paths can also be used if you want to save the result somewhere else on the system, like "/etc/myservice".</li>
</ul>
<pre><code class="language-yaml">fileName : myfile.conf
</code></pre>
<p>The fileName field are used together with the directory field mentioned earlier to create a full path for where to write the resulting data of a repply message.</p>
<pre><code class="language-yaml">schedule : [2,5]
</code></pre>
<p>Schedule are used for scheduling the method of messages to be executed several times. The schedule is defined as an array of two values, where the first value defines how often the schedule should trigger a run in seconds, and the second value is for how long the schedule are allowed to run in seconds total. <code>[2,5]</code> will trigger the method to be executed again every 2 seconds, but when a total time of 5 seconds have passed it will stop scheduling.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nats-timeouts"><a class="header" href="#nats-timeouts">Nats timeouts</a></h1>
<p>The various timeouts for the NATS messages can be controlled via an .env file or flags.</p>
<p>If the network media is a high latency like satellite links, it will make sense to adjust the client timeout to reflect the latency</p>
<pre><code class="language-text">  -natsConnOptTimeout int
        default nats client conn timeout in seconds (default 20)
</code></pre>
<p>The interval in seconds the nats client should try to reconnect to the nats-server if the connection is lost.</p>
<pre><code class="language-text">  -natsConnectRetryInterval int
        default nats retry connect interval in seconds. (default 10)
</code></pre>
<p>Jitter values.</p>
<pre><code class="language-text">  -natsReconnectJitter int
        default nats ReconnectJitter interval in milliseconds. (default 100)
  -natsReconnectJitterTLS int
        default nats ReconnectJitterTLS interval in seconds. (default 5)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="startup-folder"><a class="header" href="#startup-folder">Startup folder</a></h1>
<p>Messages can be automatically scheduled to be read and executed at startup of ctrl.</p>
<p>A folder named <strong>startup</strong> will be present in the working directory of ctrl. To inject messages at startup, put them here.</p>
<p>Messages put in the startup folder will not be sent to the broker but handled locally, and only (eventually) the reply message from the Request Method called will be sent to the broker.</p>
<p>This can be really handy when you have some 1-off job you want to done at startup, like some cleaning up.</p>
<p>Another example could be that you have some local prometheus metrics you want to scrape every 5 minutes, and you want to send them to some central metrics system.</p>
<h4 id="how-to-send-the-reply-to-another-node"><a class="header" href="#how-to-send-the-reply-to-another-node">How to send the reply to another node</a></h4>
<p>Normally the <strong>fromNode</strong> field is automatically filled in with the node name of the node where a message originated. Since messages within the startup folder is not received from another node via the normal message path we need set the <strong>fromNode</strong> field in the message to where we want the reply (result) delivered.</p>
<p>As an example. If You want to place a message on the startup folder of <strong>node1</strong> and send the result to <strong>node2</strong>. Specify <strong>node2</strong> as the <strong>fromNode</strong>, and <strong>node1</strong> as the <strong>toNode</strong></p>
<h4 id="use-local-as-the-tonode-nodename"><a class="header" href="#use-local-as-the-tonode-nodename">Use local as the toNode nodename</a></h4>
<p>Since messages used in startup folder are ment to be delivered locally we can simplify things a bit by setting the <strong>toNode</strong> field value of the message to <strong>local</strong>.</p>
<pre><code class="language-json">[
    {
        "toNode": "local",
        "fromNode": "central",
        "method": "REQCliCommand",
        "methodArgs": [
            "bash",
            "-c",
            "curl localhost:2111/metrics"
        ],
        "replyMethod": "REQToConsole",
        "methodTimeout": 10
    }
]

</code></pre>
<p>This example message will be read at startup, and executed on the local node where it was read, the method will be executed, and the result of the method will be sent to <strong>central</strong>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ctrl_data-variable"><a class="header" href="#ctrl_data-variable">{{ctrl_DATA}} variable</a></h1>
<p>By using the <code>{{ctrl_DATA}}</code> you can grab the result output of your initial request method, and then use it as input in your reply method.</p>
<p><strong>NB:</strong> The echo command in the example below will remove new lines from the data. To also keep any new lines we need to put escaped <strong>quotes</strong> around the template variable. Like this:</p>
<ul>
<li><code>\"{{ctrl_DATA}}\"</code></li>
</ul>
<p>Example of usage:</p>
<pre><code class="language-json">[
    {
        "directory":"cli_command_test",
        "fileName":"cli_command.result",
        "toNode": "node2",
        "method":"REQCliCommand",
        "methodArgs": ["bash","-c","tree"],
        "replyMethod":"REQCliCommand",
        "replyMethodArgs": ["bash", "-c","echo \"{{ctrl_DATA}}\" &gt; apekatt.txt"],
        "replyMethodTimeOut": 10,
        "ACKTimeout":3,
        "retries":3,
        "methodTimeout": 10
    }
]
</code></pre>
<p>The above example, with steps explained:</p>
<ul>
<li>Send a message from <strong>node1</strong> to <strong>node2</strong> with a Request Method of type REQCliCommand.</li>
<li>When received at <strong>node2</strong> we execute the Reqest Method with the arguments specified in the methodArgs.</li>
<li>When the method on <strong>node2</strong> is done the result data of the method run will be stored in the variable {{ctrl_DATA}}. We can then use this variable when we craft the reply message method by embedding it into a new bash command.</li>
<li>The reply message is then sent back to <strong>node1</strong>, the method will be executed, and all newlines in the result data will be removed, and all the data with the new lines removed will be stored in a file called <code>apekatt.txt</code></li>
</ul>
<p>The same using bash's herestring:</p>
<pre><code class="language-json">[
    {
        "directory":"cli_command_test",
        "fileName":"cli_command.result",
        "toNode": "ship2",
        "method":"REQCliCommand",
        "methodArgs": ["bash","-c","tree"],
        "replyMethod":"REQCliCommand",
        "replyMethodArgs": ["bash", "-c","cat &lt;&lt;&lt; {{ctrl_DATA}} &gt; hest.txt"],
        "replyMethodTimeOut": 10,
        "ACKTimeout":3,
        "retries":3,
        "methodTimeout": 10
    }
]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="errors"><a class="header" href="#errors">Errors</a></h1>
<p>Errors happening on <strong>all</strong> nodes will be reported back to the node(s) started with the flag <code>-isCentralErrorLogger</code> set to true, or by using the <code>IS_CENTRAL_ERROR_LOGGER</code> env variable.</p>
<h2 id="log-level"><a class="header" href="#log-level">Log level</a></h2>
<p>The log level can also be specified with the <code>LOG_LEVEL</code> env variable. Values are <code>error/info/warning/debug/none</code>.</p>
<h2 id="debug"><a class="header" href="#debug">Debug</a></h2>
<p>To get more debug information in the logs printed to STDERR the env variable <code>ENABLE_DEBUG</code> can be set to true. This will not affect the information printed to the log files, only to STDERR.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reqhttpget"><a class="header" href="#reqhttpget">REQHttpGet</a></h1>
<p>In JSON.</p>
<pre><code class="language-json">[
    {
        "directory": "httpget",
        "fileName": "finn.no.html",
        "toNodes": ["node1","node2"],
        "method":"REQHttpGet",
        "methodArgs": ["https://finn.no"],
        "replyMethod":"REQToFile",
        "ACKTimeout":5,
        "retries":3,
        "methodTimeout": 5
    }
]
</code></pre>
<p>In YAML.</p>
<pre><code class="language-yaml">---
- toNodes:
    - ["node1","node2"]
  method: REQHttpGet
  methodArgs:
    - "https://finn.no"
  replyMethod: REQToFile
  ACKTimeout: 5
  retries: 3
  methodTimeout: 5
  directory: httpget
  fileName: finn.no.html
</code></pre>
<p>The result html file of the http get will be written to:</p>
<ul>
<li>&lt;data folder&gt;\httpget\node1\finn.no.html</li>
<li>&lt;data folder&gt;\httpget\node2\finn.no.html</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reqtailfile"><a class="header" href="#reqtailfile">REQTailFile</a></h1>
<p>In JSON.</p>
<pre><code class="language-json">[
    {
        "directory": "tails",
        "fileName": "some.log",
        "toNodes": "node1","node2","node3",
        "method":"REQTailFile",
        "methodArgs": ["/var/log/syslog"],
        "ACKTimeout":5,
        "retries":3,
        "methodTimeout": 200
    }
]
</code></pre>
<p>NB: If no replyMethod are specified, it will default to <strong>REQToFile</strong></p>
<p>In YAML.</p>
<pre><code class="language-yaml">---
- toNodes:
    - ["node1","node2","node3"]
  method: REQTailFile
  methodArgs:
    - "/var/log/syslog"
  replyMethod: REQToFile
  ACKTimeout: 5
  retries: 3
  methodTimeout: 5
  directory: tails
  fileName: var_log_syslog.log
</code></pre>
<p>The above example will tail the syslog file on 3 nodes for 5 seconds, and save the result on the node where the request came from in the local <code>data</code> folder.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reqclicommand"><a class="header" href="#reqclicommand">REQCliCommand</a></h1>
<p>In JSON.</p>
<pre><code class="language-json">[
    {
        "directory":"system",
        "fileName":"system.log",
        "toNodes": ["node2"],
        "method":"REQCliCommand",
        "methodArgs": ["bash","-c","rm -rf ./data &amp; systemctl restart ctrl"],
        "replyMethod":"REQToFileAppend",
        "ACKTimeout":30,
        "retries":1,
        "methodTimeout": 30
    }
]
</code></pre>
<p>In YAML.</p>
<pre><code class="language-yaml">---
- toNodes:
    - node2
  method: REQCliCommand
  methodArgs:
    - "bash"
    - "-c"
    - |
      rm -rf ./data &amp; systemctl restart ctrl

  replyMethod: REQToFileAppend
  ACKTimeout: 30
  retries: 1
  ACKTimeout: 30
  directory: system
  fileName: system.log
</code></pre>
<p>Will send a message to node2 to delete the ctrl data folder, and then restart ctrl. The end result will be appended to the specified file on the node where the request originated.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="send-more-messages"><a class="header" href="#send-more-messages">Send more messages</a></h1>
<pre><code class="language-json">[
    {
        "directory":"cli-command-executed-result",
        "fileName": "some.log",
        "toNode": "ship1",
        "method":"REQCliCommand",
        "methodArgs": ["bash","-c","sleep 3 &amp; tree ./"],
        "ACKTimeout":10,
        "retries":3,
        "methodTimeout": 4
    },
    {
        "directory":"cli-command-executed-result",
        "fileName": "some.log",
        "toNode": "ship2",
        "method":"REQCliCommand",
        "methodArgs": ["bash","-c","sleep 3 &amp; tree ./"],
        "ACKTimeout":10,
        "retries":3,
        "methodTimeout": 4
    }
]
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
